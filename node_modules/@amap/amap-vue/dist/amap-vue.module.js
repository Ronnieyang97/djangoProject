import e from"vue";var t={_prefix:"https://webapi.amap.com/maps",_disableMapCache:!1,verbose:!1,timing:!1,version:"2.0",key:"",plugins:[]};function n(){const e={};return e.promise=new Promise((t,n)=>{e.resolve=t,e.reject=n}),e}const o=n();let r=!1,a=!1;const i=o.promise;function s(){if(!a){if(a=!0,window.AMap)return o.resolve(window.AMap),i;const e=document.createElement("script"),n=`amap_vue_${Date.now()}_${Math.ceil(1e4*Math.random())}`,s=()=>{r||(r=!0,o.resolve(window.AMap))};window[n]=s;const p=function(e){const t=[];for(const n in e)void 0!==e[n]&&null!==e[n]&&t.push(`${n}=${encodeURIComponent(e[n])}`);return t.join("&")}({v:t.version,key:t.key,callback:n,plugin:t.plugins.join(",")}),l=`${t._prefix}?${p}`;e.src=l,document.body.appendChild(e)}return i}async function p(e){const t=await s();return new Promise(n=>{t.plugin(e,()=>{n()})})}var l=e.extend({inject:["$amapMap"],computed:{$map(){return this.$amapMap.target}}});function c(e){throw new Error(e)}function d(e,...t){const[n,...o]=t;if(!n)return e;const r=new Set(e);return n.forEach(t=>{r.has(t)||e.push(t)}),d(e,...o)}const u=Object.prototype.hasOwnProperty;function m(e){try{if(e.constructor&&!u.call(e,"constructor")&&!u.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(e){return!1}let t;for(t in e);return void 0===t||u.call(e,t)}function y(...t){return e.extend({mixins:t||[]})}function f(e,n,o){t.verbose&&"function"==typeof console[n]&&(e&&e.$options&&e.$options.name&&(o=[`[${e.$options.name}]`,...o]),console[n](...o))}function h(...e){f(this,"warn",e)}function g(...e){f(this,"debug",e)}function v(e){return{warn:h.bind(e),debug:g.bind(e)}}function b(e,t){return null!=t&&e instanceof t}function w(e,t,n,o,r){"object"==typeof t&&(n=t.depth,o=t.prototype,r=t.includeNonEnumerable,t=t.circular);let a=[],i=[];return void 0===t&&(t=!0),void 0===n&&(n=1/0),function e(n,s){if(null===n)return null;if(0===s)return n;let p,l;if("object"!=typeof n)return n;if(b(n,Map))p=new Map;else if(b(n,Set))p=new Set;else if(b(n,Promise))p=new Promise((function(t,o){n.then((function(n){t(e(n,s-1))}),(function(t){o(e(t,s-1))}))}));else if(w.__isArray(n))p=[];else if(w.__isRegExp(n))p=new RegExp(n.source,M(n)),n.lastIndex&&(p.lastIndex=n.lastIndex);else if(w.__isDate(n))p=new Date(n.getTime());else if(b(n,Error))p=Object.create(n);else if(void 0===o){if(l=Object.getPrototypeOf(n),b(l,Object))return n;p=Object.create(l)}else p=Object.create(o),l=o;if(t){let e=a.indexOf(n);if(-1!=e)return i[e];a.push(n),i.push(p)}b(n,Map)&&n.forEach((function(t,n){let o=e(n,s-1),r=e(t,s-1);p.set(o,r)})),b(n,Set)&&n.forEach((function(t){let n=e(t,s-1);p.add(n)}));for(let t in n){Object.getOwnPropertyDescriptor(n,t)&&(p[t]=e(n[t],s-1));try{if(void 0===Object.getOwnPropertyDescriptor(n,t).set)continue;p[t]=e(n[t],s-1)}catch(e){if(e instanceof TypeError)continue;if(e instanceof ReferenceError)continue}}if(Object.getOwnPropertySymbols){let t=Object.getOwnPropertySymbols(n);for(let o=0;o<t.length;o++){let a=t[o],i=Object.getOwnPropertyDescriptor(n,a);(!i||i.enumerable||r)&&(p[a]=e(n[a],s-1),Object.defineProperty(p,a,i))}}if(r){let t=Object.getOwnPropertyNames(n);for(let o=0;o<t.length;o++){let r=t[o],a=Object.getOwnPropertyDescriptor(n,r);a&&a.enumerable||(p[r]=e(n[r],s-1),Object.defineProperty(p,r,a))}}return p}(e,n)}function $(e){return Object.prototype.toString.call(e)}function M(e){let t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),t}function C(e){const t=[];for(;Array.isArray(e);)t.push(e.length),e=e[0];return t}function A(e,t){return!(!e&&t)&&(!(e&&!t)&&(e===t||e.length===t.length&&e.every((e,n)=>e===t[n])))}function x(e,t){return!(!e&&t)&&(!(e&&!t)&&(e===t||e[0]===t[0]&&e[1]===t[1]))}function k(e,t){if(!e&&t)return!1;if(e&&!t)return!1;if(!e&&!t)return!0;if(e===t)return!0;if(e.length!==t.length)return!1;const n=C(e);return!!A(n,C(t))&&(2===n.length?e.every((e,n)=>x(e,t[n])):3===n.length&&e.every((e,n)=>k(e,t)))}e.mixin({beforeCreate(){this.$options}}),e.config.optionMergeStrategies.amapMeta=(e,t)=>function e(t,n){const o={...t};for(const r in n){const a=n[r],i=t[r];Array.isArray(a)?o[r]=d(i||[],a):m(a)?o[r]=e(i||{},a):o[r]=a}return o}(e||{},t||{}),w.clonePrototype=function(e){if(null===e)return null;let t=function(){};return t.prototype=e,new t},w.__objToStr=$,w.__isDate=function(e){return"object"==typeof e&&"[object Date]"===$(e)},w.__isArray=function(e){return"object"==typeof e&&"[object Array]"===$(e)},w.__isRegExp=function(e){return"object"==typeof e&&"[object RegExp]"===$(e)},w.__getRegExpFlags=M;function E(e,t,n=1e-7){return Math.abs(e-t)<n}function S(e,t){return!(!e&&t)&&(!(e&&!t)&&(e===t||E(e[0],t[0])&&E(e[1],t[1])))}const O=new WeakMap;function B(e,t){let n=O.get(t);if(!n){n=new Map,O.set(t,n);for(const e in t){const o=t[e];!1!==o.initialize&&n.set(e,o)}}return n.get(e)}function _(e,t,n,o){void 0===t&&(t=e.$options.props),void 0===n&&(n=e.$props);const r={};for(const o in n){const a=n[o];if(void 0===a)continue;const i=B(o,t);i&&(r[o]=i.transform?i.transform.call(e,a):a)}return o?r:w(r)}function j(e){return e?Array.isArray(e)?[e[0],e[1]]:[e.lng,e.lat]:[]}function L(e){return Array.isArray(e)?e:e.southWest?[[e.southWest.lng,e.southWest.lat],[e.northEast.lng,e.northEast.lat]]:[[e.southwest.lng,e.southwest.lat],[e.northeast.lng,e.northeast.lat]]}function P(e){if(!Array.isArray(e))return[];const t=C(e);return 1===t.length||2===t.length?e.map(j):3===t.length?e.map(e=>e.map(j)):[]}function T(e){const t=new AMap.LngLat(e[0][0],e[0][1]),n=new AMap.LngLat(e[1][0],e[1][1]);return new AMap.Bounds(t,n)}function z(e){return(t,n)=>{t.setOptions({[e]:n})}}function D(e,t,n){const o=e.$amap.events||(e.$amap.events={});(o[t]||(o[t]=[])).push(n)}function N(e){const{events:t=[]}=e.$options.amapMeta,n=e.$amap.context.target;t.forEach(t=>{e.$watch("$listeners."+t,(o,r)=>{r&&n.off(t,r),o&&(D(e,t,o),n.on(t,o))},{immediate:!0})})}function I(e,t,n,o){o||(o=e.$amap.context.target);const{events:r=[]}=n;r.forEach(r=>{const{getter:a}=n;if(!a)return;const i=r=>{const i="function"==typeof a?a.call(e,o,r):o[a](),s=e.$props[t];if("function"==typeof n.equals){if(n.equals(i,s))return}else if(i===s)return;e.$emit("update:"+t,i)};D(e,r,i),o.on(r,i)})}function R(e){const t=e.$amap.context.target,n=e.$amap.events||{};for(const e in n){n[e].forEach(n=>{t.off(e,n)})}}const q={equals:function(e,t){return e===t},clone:!1};function W(e,t,n,o){const{setter:r}=n;r&&("function"==typeof r?r.call(e,t,o):"string"==typeof r&&(n.clone&&(o=w(o)),t[r](o)))}function Z(e,t,n){t||(t=e.$amap.context.target),n||(n=e.$options.props);for(const o in n){const r=n[o],{setter:a}=r;if(!a)continue;const i={deep:!!r.deep};e.$amap.logger.debug("watch",o,i),e.$watch("$props."+o,(n,o)=>{if(!i.deep||i.deep&&n!==o)if("function"==typeof r.equals){if(r.equals(n,o))return}else if(n===o)return;W(e,t,r,n)},i),r.events&&I(e,o,r,t)}}function F(e,t,n){if("string"==typeof e){const o=e,r={...q,setter:o};return t&&(r.type=t),arguments.length>=3&&(r.default=n),r}return{...q,...e}}function U(e){return function(t,n){t.setStatus({[e]:n})}}var H=e.extend({name:"Amap",amapMeta:{events:["click","dblclick","rightclick","mapmove","movestart","moveend","hotspotclick","hotspotover","hotspotout","mousemove","mousewheel","mouseover","mouseup","mousedown","zoomchange","zoomstart","zoomend","dragstart","dragging","dragend","resize","touchstart","touchmove","touchend"]},props:{cacheKey:F({type:String,initialize:!1}),center:F({type:Array,deep:!0,equals:x,setter(e,t){if(!t)return;S(t,j(e.getCenter()))||e.setCenter([t[0],t[1]])},getter:e=>j(e.getCenter()),events:["mapmove","moveend"]}),zoom:F({type:Number,equals:E,setter(e,t){if(void 0===t)return;E(e.getZoom(),t)||e.setZoom(t)},getter:"getZoom",events:["zoomchange","zoomend"]}),rotation:F({type:Number,equals:E,setter:"setRotation",getter:"getRotation",events:["dragging","dragend","moveend","rotateend"]}),pitch:F({type:Number,equals:E,setter:"setPitch",getter:"getPitch",events:["dragging","dragend","moveend","pitchend"]}),viewMode:{type:String},features:F("setFeatures",Array),zooms:{type:Array},dragEnable:F({type:Boolean,default:void 0,setter:U("dragEnable")}),zoomEnable:F({type:Boolean,default:void 0,setter:U("zoomEnable")}),jogEnable:F({type:Boolean,default:void 0,setter:U("jogEnable")}),pitchEnable:F({type:Boolean,default:void 0,setter:U("pitchEnable")}),rotateEnable:F({type:Boolean,default:void 0,setter:U("rotateEnable")}),animateEnable:F({type:Boolean,default:void 0,setter:U("animateEnable")}),keyboardEnable:F({type:Boolean,default:void 0,setter:U("keyboardEnable")}),doubleClickZoom:F({type:Boolean,default:void 0,setter:U("doubleClickZoom")}),scrollWheel:F({type:Boolean,default:void 0,setter:U("scrollWheel")}),touchZoom:{type:Boolean,default:void 0},touchZoomCenter:{type:Boolean,default:void 0},showLabel:{type:Boolean,default:void 0},defaultCursor:F("setDefaultCursor",String),isHotspot:F({type:Boolean,default:void 0,setter:U("isHotspot")}),mapStyle:F("setMapStyle",String),wallColor:{type:String},roofColor:{type:String},skyColor:{type:String},showBuildingBlock:{type:Boolean,default:void 0},showIndoorMap:F({type:Boolean,default:void 0,setter:U("showIndoorMap")}),mask:{type:Array}},data:()=>({ready:!1}),computed:{$context(){return this.$amap.context},$map(){return this.$context.target}},methods:{_clear(){const{$context:e}=this;e.ready.then(()=>{R(this);const{$map:e}=this;e.clearMap(),e.clearInfoWindow()})},_getContainer(e){const{cacheKey:n}=this;if(!t._disableMapCache&&n){const t="amap-vue-container-inner-"+n;let o=document.getElementById(t)||this.$el.querySelector("#"+t);return o||(o=document.createElement("div"),o.className="amap-vue-container-inner",o.setAttribute("id",t),o.setAttribute("style","position:relative; width:100%; height:100%;")),e?(this.$el.insertAdjacentElement("afterbegin",o),o.style.display="block",o.style.pointerEvents="initial"):(o.style.display="none",o.style.pointerEvents="none"),o}return this.$el}},beforeCreate(){s();const e=n(),t={AMap:null,wrapper:null,ready:e.promise,target:null,vm:this,destroyed:!1};this.$amap={events:{},ready:e,context:t,logger:v(this)}},async mounted(){const{$context:e}=this,t=await s();if(e.AMap=t,e.destroyed)return;const n=_(this),o=this._getContainer(!0),r=!!o.$amap;if(r)for(let e in n){const t=this.$options.props[e],r=n[e];W(this,o.$amap,t,r)}else o.$amap=new t.Map(o,n);const a=o.$amap;e.wrapper=o,e.target=a,Z(this),N(this);const i=async()=>{this.ready=!0,this.$amap.ready.resolve(a),await this.$nextTick(),this.$emit("complete",a)};r?i():a.on("complete",i)},destroyed(){const{$context:e}=this;if(!t._disableMapCache&&this.cacheKey){const e=this._getContainer(!1);document.body.appendChild(e),this._clear()}else e.target&&e.target.destroy();e.destroyed=!0},provide(){return{$amapMap:this.$context}},render(e){let t=this.$slots.default;return this.ready||(t=void 0),e("div",{class:"amap-vue-container",style:"position:relative; width:100%; height:100%;"},t)}}),K=e.extend({computed:{$context(){return this.$amap.context},$container(){return this.$amapMap},$target(){return this.$context.target},$map(){return this.$amapMap.target},$meta(){return this.$options.amapMeta}}}),J=y(K).extend({inject:["$amapMap"],amapMeta:{slot:!1,initComponent:c,add(e,t){t.setMap(e.target)},remove(e,t){t.setMap(null)}},beforeCreate(){const e=n(),t={AMap:null,ready:e.promise,target:null,vm:this,destroyed:!1};this.$amap={events:{},ready:e,context:t,logger:v(this)}},async mounted(){const{$amap:e,$context:t,$container:n}=this,o=this.$options.amapMeta;await n.ready,t.AMap=n.AMap,o.prepare&&await o.prepare();const r=_(this);if(t.destroyed)return;const a=await o.initComponent.call(this,t.AMap,r);t.target=a,o.add.call(this,n,a),Z(this),N(this),e.ready.resolve(a),this.$emit("amap-ready",a)},beforeDestroy(){const{$context:e,$container:t,$target:n}=this;if(n){R(this),this.$options.amapMeta.remove.call(this,t,n)}e.destroyed=!0},render(e){return this.$options.amapMeta.slot&&this.$slots.default?e("div",{class:"amap-vue-placeholder",style:"visibility: hidden; pointer-events: none;"},this.$slots.default):null}});function V(e,t,n,o){"function"==typeof e[n]?e[n](o):"function"==typeof e.setOptions&&e.setOptions({[t]:o})}function G(t,n="show",o="hide"){return e.extend({props:{visible:F({type:Boolean,default:t,setter(e,t){t?e[n]():e[o]()}})}})}const Y=e.extend({props:{zIndex:F({type:Number,setter(e,t){V(e,"zIndex","setzIndex",t)}})}}),Q=e.extend({props:{opacity:F("setOpacity",Number)}}),X=e.extend({props:{zooms:F({type:Array,deep:!0,equals:x,setter(e,t){V(e,"zooms","setZooms",t)}})}});var ee=y(J,G(!0),Y).extend({amapMeta:{events:["click","dblclick","rightclick","mousemove","mouseover","mouseout","mousedown","mouseup","dragstart","dragging","dragend","moving","moveend","movealong","touchstart","touchmove","touchend"]},props:{cursor:F({type:String,setter(e,t){"function"==typeof e.setCursor?e.setCursor(t):"function"==typeof e.setOptions&&e.setOptions({cursor:t})}}),bubble:F("setBubble",Boolean,void 0),clickable:F("setClickable",Boolean,void 0),draggable:F("setDraggable",Boolean,void 0),extData:F("setExtData",Object)},async mounted(){const{$context:e}=this;await e.ready,e.destroyed||this.visible||e.target.hide()}});const te=["top-left","top-center","top-right","middle-left","center","middle-right","bottom-left","bottom-center","bottom-right"],ne=["miter","round","bevel"],oe=["butt","round","square"],re=["solid","dashed"];var ae=y(ee,X).extend({props:{position:F({type:Array,deep:!0,equals:x,setter(e,t){if(!t)return;S(t,j(e.getPosition()))||e.setPosition([t[0],t[1]])},getter:e=>j(e.getPosition()),events:["dragging","dragend","moving","moveend"]}),title:F("setTitle",String),offset:F({type:Array,deep:!0,equals:x,setter(e,t){const n=e;var o;t&&(S(t,(o=n.getOffset(),Array.isArray(o)?[o[0],o[1]]:[o.x,o.y]))||n.setOffset(new window.AMap.Pixel(t[0],t[1])))},transform:e=>new window.AMap.Pixel(e[0],e[1])}),anchor:F({type:String,setter:"setAnchor",validator:e=>te.includes(e)}),angle:F({type:Number,equals:E,setter(e,t){void 0!==t&&e.setAngle(t)},getter:e=>e.getAngle(),events:["moving"]}),topWhenClick:{type:Boolean,default:void 0}},beforeDestroy(){const e=this.$context.target;e&&"function"==typeof e.stopMove&&e.stopMove()}});function ie(e){if(!e)return;const t={...e};return t.offset&&(t.offset=new window.AMap.Pixel(t.offset[0],t.offset[1])),t}function se(e){return"string"==typeof e?e:new window.AMap.Icon(e)}var pe=y(ae).extend({name:"AmapMarker",amapMeta:{slot:!0,async initComponent(e,t){const n={...t};return this.$slots.default&&this.$slots.default.length>0&&(n.content=this.$slots.default[0].elm),new e.Marker(n)}},props:{content:F("setContent",String),icon:F({setter(e,t){if(!t)return;const n=se(t);e.setIcon(n)},transform:se}),label:F({type:Object,setter(e,t){t&&e.setLabel(ie(t))},deep:!0,transform:ie})}}),le=y(J,G(!0),Y,Q,X).extend({name:"AmapLabelsLayer",amapMeta:{slot:!0,initComponent:async(e,t)=>new e.LabelsLayer(t)},props:{visible:F({type:Boolean,default:!0,setter(e,t){const n=e;t?n.show():n.hide()}}),zIndex:F("setzIndex",Number),opacity:F("setOpacity",Number),collision:F({type:Boolean,default:void 0,setter:"setCollision"}),allowCollision:F({type:Boolean,default:void 0,setter:"setAllowCollision"})},provide(){return{$amapLabelsLayer:this.$context}},data:()=>({ready:!1}),mounted(){this.$context.ready.then(()=>this.ready=!0)},render(e){let t=this.$slots.default;return this.ready||(t=void 0),e("div",{class:"amap-vue-labels-layer",style:"visibility: hidden; pointer-events: none;"},t)}}),ce=y(J,G(!0),Y,Q,X).extend({name:"AmapLabelMarker",inject:["$amapLabelsLayer"],amapMeta:{initComponent:async(e,t)=>new e.LabelMarker(t),async add(e,t){const n=this.$layer;n&&n.add(t)},async remove(e,t){const n=this.$layer;n&&n.remove(t)},events:["mousedown","mouseup","touchstart","touchmove","touchend","click","mousemove","mouseover","mouseout"]},props:{name:F("setName",String),position:F({type:Array,deep:!0,equals:x,setter(e,t){if(!t)return;S(t,j(e.getPosition()))||e.setPosition([t[0],t[1]])}}),rank:F("setRank",Number),icon:F({type:Object,setter:"setIcon",deep:!0}),text:F({type:Object,setter:"setText",deep:!0})},computed:{$layerContext(){return this.$amapLabelsLayer},$layer(){const{$layerContext:e}=this;return e?e.target:null}},mounted(){const{$layerContext:e}=this;if(!e)throw new Error("LabelMarker 需要与 LabelsLayer 配合使用")}}),de=y(ae).extend({name:"AmapText",amapMeta:{initComponent:async(e,t)=>(t.domStyle&&(t.style=t.domStyle,delete t.domStyle),new e.Text(t))},props:{text:F({type:[String,Object],setter:"setText"}),domStyle:F({type:Object,setter(e,t){e.setStyle(t)},deep:!0})}});const ue=y(ee).extend({props:{strokeColor:F({type:String,setter:z("strokeColor")}),strokeOpacity:F({type:Number,setter:z("strokeOpacity")}),strokeWeight:F({type:Number,setter:z("strokeWeight")}),strokeStyle:F({type:String,setter:z("strokeStyle"),validator:e=>re.includes(e)}),strokeDasharray:F({type:Array,deep:!0,equals:A,setter:z("strokeDasharray")})}}),me=y(ue).extend({props:{fillColor:F({type:String,setter:z("fillColor")}),fillOpacity:F({type:Number,setter:z("fillOpacity")})}}),ye=y(ue).extend({props:{lineJoin:F({type:String,setter:z("lineJoin"),validator:e=>ne.includes(e)}),lineCap:F({type:String,setter:z("lineCap"),validator:e=>oe.includes(e)}),showDir:F({type:Boolean,default:void 0,setter:z("showDir")}),dirColor:F({type:String,setter:z("dirColor")}),dirImg:F({type:Object,setter:z("dirImg")}),isOutline:F({type:Boolean,default:void 0,setter:z("isOutline")}),outlineColor:F({type:String,setter:z("outlineColor")}),borderWeight:F({type:Number,setter:z("borderWeight")}),geodesic:F({type:Boolean,default:void 0,setter:z("geodesic")})}});var fe=y(me).extend({props:{center:F({type:Array,clone:!0,deep:!0,equals:x,setter(e,t){if(t){if(this.$props.draggable||this.$props.editable){if(S(t,j(e.getCenter())))return}e.setCenter([t[0],t[1]])}},getter:e=>j(e.getCenter()),events:["dragging","dragend"]}),radius:F({type:Number,setter:"setRadius"})}});const he=y(K).extend({data:()=>({$editor:null}),props:{editable:F({type:Boolean,default:!1,initialize:!1})},computed:{$editable(){return this.$meta.editable}},async mounted(){await this.$context.ready;const e=this.$options.amapMeta.editable;this.editable&&e.startEditing.call(this)},beforeDestroy(){const{$editor:e,$context:t}=this;if(e){if(this.$options.amapMeta.editable.events.forEach(t=>{e.off(t,this.$onAmapEdit)}),e.close(),t&&t.target){t.target.setMap(null)}}},watch:{"$props.editable"(e){const{$editable:t,$context:n}=this;e?n.destroyed||t.startEditing.call(this):t.endEditing.call(this)}}});var ge=y(he).extend({amapMeta:{editable:{events:[],loadEditor:c,initEditor:c,onEdit:c,async initEditing(){if(this.$editor)return this.$editor;const e=this.$options.amapMeta.editable,{$container:t,$context:n,$editable:o,$map:r}=this;await t.ready,await o.loadEditor();const{AMap:a}=n;this.$editor=await e.initEditor.call(this,a,r,n.target);const i=this.$onAmapEdit=e.onEdit.bind(this);return e.events.forEach(e=>{this.$editor.on(e,i)}),this.$editor},async startEditing(){const{$editable:e}=this;(await e.initEditing.call(this)).open()},endEditing(){this.$editor&&this.$editor.close()}}}}),ve=y(fe,ge).extend({name:"AmapCircle",amapMeta:{initComponent:async(e,t)=>new e.Circle(t),editable:{events:["end","move","adjust"],async loadEditor(){await p("AMap.CircleEditor")},async initEditor(e,t,n){return new e.CircleEditor(t,n,this.draggable)},onEdit(e){const t=e.target,n=t.getCenter();this.$emit("update:center",[n.lng,n.lat]),this.$emit("update:radius",t.getRadius())}}}}),be=y(fe).extend({name:"AmapCircleMarker",amapMeta:{initComponent:async(e,t)=>new e.CircleMarker(t)}});function we(e){return y(ue,ge).extend({amapMeta:{editable:{events:["end","move","adjust","addnode","removenode","add"],async loadEditor(){await p("AMap."+e)},async initEditor(t,n,o){return new t[e](n,o,this.draggable)},onEdit(e){const t=e.target.getPath().map(j);this.$emit("update:path",t)}}},props:{path:F({type:Array,setter(e,t){if(this.$props.draggable||this.$props.editable){if(k(P(e.getPath()),t))return}e.setPath(t)},getter:e=>P(e.getPath()),clone:!0,equals:k,events:["dragging","dragend"]})}})}var $e=y(me,we("PolygonEditor")).extend({name:"AmapPolygon",amapMeta:{initComponent:async(e,t)=>new e.Polygon(t)}}),Me=y(we("PolylineEditor"),ye).extend({name:"AmapPolyline",amapMeta:{initComponent:async(e,t)=>new e.Polyline(t)}});const Ce="undefined"!=typeof BigInt64Array;function Ae(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){if(e.constructor!==t.constructor)return!1;if(Array.isArray(e)){const n=e.length;if(n!=t.length)return!1;for(let o=n;0!=o--;)if(!Ae(e[o],t[o]))return!1;return!0}if(e instanceof Map){if(e.size!==t.size)return!1;for(const n of e.entries())if(!t.has(n[0]))return!1;for(const n of e.entries())if(!Ae(n[1],t.get(n[0])))return!1;return!0}if(e instanceof Set){if(e.size!==t.size)return!1;for(const n of e.entries())if(!t.has(n[0]))return!1;return!0}if(e.constructor.BYTES_PER_ELEMENT&&(e instanceof Int8Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array||Ce&&(e instanceof BigInt64Array||e instanceof BigUint64Array))){const n=e.length;if(n!=t.length)return!1;for(let o=n;0!=o--;)if(e[o]!==t[o])return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();const n=Object.keys(e),o=n.length;if(o!==Object.keys(t).length)return!1;for(let e=o;0!=e--;)if(!Object.prototype.hasOwnProperty.call(t,n[e]))return!1;for(let r=o;0!=r--;){const o=n[r];if(!Ae(e[o],t[o]))return!1}return!0}return e!=e&&t!=t}function xe(e){return e||[]}var ke=y(ye,ge).extend({name:"AmapBezierCurve",amapMeta:{initComponent:async(e,t)=>new e.BezierCurve(t),editable:{events:["end","adjust","addnode","removenode"],async loadEditor(){await p("AMap.BezierCurveEditor")},async initEditor(e,t,n){return new e.BezierCurveEditor(t,n,this.draggable)},onEdit(e){const t=e.target.getPath();this.$emit("update:path",xe(t))}}},props:{path:F({type:Array,setter(e,t){if(this.$props.editable||this.$props.editable){if(Ae(xe(e.getPath()),t))return}e.setPath(t)},getter:e=>xe(e.getPath()),clone:!0,equals:Ae,events:["dragging","dragend"]})}});function Ee(e,t){return!(!e||!t)&&(E(e[0][0],t[0][0])&&E(e[0][1],t[0][1])&&E(e[1][0],t[1][0])&&E(e[1][1],t[1][1]))}var Se=y(me,ge).extend({name:"AmapRectangle",amapMeta:{initComponent:async(e,t)=>new e.Rectangle(t),editable:{events:["move","end","adjust"],async loadEditor(){await p("AMap.RectangleEditor")},async initEditor(e,t,n){return new e.RectangleEditor(t,n,this.draggable)},onEdit(e){const t=L(e.target.getBounds());this.$emit("update:bounds",t)}}},props:{bounds:F({type:Array,deep:!0,setter(e,t){if(this.$props.editable||this.$props.draggable){if(Ee(L(e.getBounds()),t))return}e.setBounds(T(t))},getter:e=>L(e.getBounds()),transform:T,clone:!0,equals:Ee,events:["dragging","dragend"]})}}),Oe=y(me,ge).extend({name:"AmapEllipse",amapMeta:{initComponent:async(e,t)=>new e.Ellipse(t),editable:{events:["move","end","adjust"],async loadEditor(){await p("AMap.EllipseEditor")},async initEditor(e,t,n){return new e.EllipseEditor(t,n,this.draggable)},onEdit(e){const t=j(e.target.getCenter());S(this.center,t)||this.$emit("update:center",t);const n=e.target.getRadius();S(this.radius,n)||this.$emit("update:radius",n.slice(0))}}},props:{center:F({type:Array,setter(e,t){if(this.$props.editable||this.$props.draggable){if(S(t,j(e.getCenter())))return}e.setCenter(t)},getter:e=>j(e.getCenter()),clone:!0,deep:!0,equals:S,events:["dragging","dragend"]}),radius:F({type:Array,setter(e,t){const n=e;if(this.$props.editable){if(S(t,n.getRadius()))return}n.setRadius(t)},clone:!0,deep:!0,equals:S})}});function Be(e,t,n){if(!e)return n;var o,r;if(Array.isArray(t)&&(o=t.slice(0)),"string"==typeof t&&(o=t.split(".")),"symbol"==typeof t&&(o=[t]),!Array.isArray(o))throw new Error("props arg must be an array, a string or a symbol");for(;o.length;){if(r=o.shift(),!e)return n;if(void 0===(e=e[r]))return n}return e}var _e=y(ee,G(!0,"open","close")).extend({name:"AmapInfoWindow",amapMeta:{slot:!0,async initComponent(e,t){const n={...t},o=Be(this.$slots,"default.0.elm");return n.isCustom&&o&&(n.content=o),new e.InfoWindow(n)},events:["change","open","close"]},props:{isCustom:{type:Boolean,default:void 0},autoMove:{type:Boolean,default:void 0},avoid:F({type:Array}),closeWhenClickMap:{type:Boolean,default:void 0},content:F("setContent",String),size:F({type:Array,transform:e=>new window.AMap.Size(e[0],e[1])}),anchor:F({type:String,setter:"setAnchor",validator:e=>te.includes(e)}),offset:F({type:Array,transform:e=>new window.AMap.Pixel(e[0],e[1])}),position:F({type:Array,deep:!0,setter(e,t){if(!t)return;const n=e.getPosition();n&&S(t,j(n))||e.setPosition([t[0],t[1]])},getter:e=>j(e.getPosition()),equals:x})},methods:{open(){this.$context.ready.then(e=>{const t=this.position;e.open(this.$map,t)})},close(){this.$context.ready.then(e=>{e.close()})},onOpen(){this.visible||this.$emit("update:visible",!0)},onClose(){this.visible&&this.$emit("update:visible",!1)},_updateContent(){this.visible&&this.$nextTick(()=>{const e=Be(this.$slots,"default.0.elm",this.content);this.$context.ready.then(t=>{t.setContent(e)})})}},async mounted(){const e=await this.$context.ready;this.visible&&(this._updateContent(),this.open()),e.on("open",this.onOpen),e.on("close",this.onClose)},watch:{visible:"_updateContent",content:"_updateContent"}}),je=y(J,G(!0),Y,Q,X).extend({amapMeta:{events:["complete"]},props:{tileSize:{type:Number}},async mounted(){await this.$context.ready,this.$context.destroyed||this.visible||this.$target.hide()}}),Le=y(je).extend({name:"AmapTileLayer",amapMeta:{initComponent:async(e,t)=>new e.TileLayer(t)},props:{tileUrl:F({type:String,setter:"setTileUrl"}),dataZooms:F({type:Array})}}),Pe=y(je).extend({name:"AmapSatelliteLayer",amapMeta:{initComponent:async(e,t)=>new e.TileLayer.Satellite(t)}}),Te=y(je).extend({name:"AmapFlexibleLayer",amapMeta:{initComponent:async(e,t)=>new e.TileLayer.Flexible(t)},props:{createTile:{type:Function},cacheSize:{type:Number}}}),ze=y(je).extend({name:"AmapRoadNetLayer",amapMeta:{initComponent:async(e,t)=>new e.TileLayer.RoadNet(t)}}),De=y(je).extend({name:"AmapTrafficLayer",amapMeta:{initComponent:async(e,t)=>new e.TileLayer.Traffic(t)},props:{autoRefresh:{type:Boolean,default:void 0},interval:{type:Number}}});const Ne=["LT","RT","LB","RB"],Ie=y(J,G(!0)).extend({amapMeta:{add(e,t){e.target.addControl(t)},remove(e,t){e.target.removeControl(t)},events:["show","hide"]}}),Re=e.extend({props:{offset:F({type:Array})}}),qe=e.extend({props:{position:F({type:[Object,String],validator:e=>"object"==typeof e||Ne.includes(e)})}});var We=y(Ie).extend({name:"AmapMapType",amapMeta:{prepare:()=>p("AMap.MapType"),initComponent:async(e,t)=>new e.MapType(t)},props:{defaultType:{type:Number},showTraffic:{type:Boolean,default:void 0},showRoad:{type:Boolean,default:void 0}}}),Ze=y(Ie,Re,qe).extend({name:"AmapControlBar",amapMeta:{prepare:()=>p("AMap.ControlBar"),initComponent:async(e,t)=>new e.ControlBar(t)},props:{showControlButton:{type:Boolean,default:void 0}}}),Fe=y(Ie,Re,qe).extend({name:"AmapHawkEye",amapMeta:{prepare:()=>p("AMap.HawkEye"),initComponent:async(e,t)=>new e.HawkEye(t)},props:{visible:F({type:Boolean,default:!0,setter(e,t){const n=e;t?n.show():n.hide()}}),isOpen:F({type:Boolean,default:void 0,setter(e,t){const n=e;t?n.open():n.hide()}}),autoMove:{type:Boolean,default:void 0},showRectangle:{type:Boolean,default:void 0},showButton:{type:Boolean,default:void 0},mapStyle:{type:String,default:void 0},layers:{type:Array,default:void 0},width:{type:String,default:void 0},height:{type:String,default:void 0},borderStyle:{type:String,default:void 0},borderColor:{type:String,default:void 0},borderRadius:{type:String,default:void 0},borderWidth:{type:String,default:void 0},buttonSize:{type:String,default:void 0}}}),Ue=y(Ie,Re,qe).extend({name:"AmapScale",amapMeta:{prepare:()=>p("AMap.Scale"),initComponent:async(e,t)=>new e.Scale(t)}}),He=y(Ie,Re,qe).extend({name:"AmapToolBar",amapMeta:{prepare:()=>p("AMap.ToolBar"),initComponent:async(e,t)=>new e.ToolBar(t)}});const Ke=new Map,Je=new Map;function Ve(e){const t=Je.get(e);if(!t)return;const{ops:n,milliseconds:o}=t,r=n/o*1e3;console.log(`${e}: ${n}ops, ${o.toFixed(2)}ms, ${r.toFixed(2)}ops/s`)}function Ge(e){t.timing&&performance&&performance.now&&Ke.set(e,performance.now())}function Ye(e,n=1){if(!t.timing)return;if(!performance||!performance.now)return;const o=performance.now(),r=Ke.get(e);if(Ke.delete(e),!r)return;const a=o-r,i=Je.get(e)||{ops:0,milliseconds:0};i.ops+=n||1,i.milliseconds+=a,Je.set(e,i)}"undefined"!=typeof window&&(window.__amap_perf__={start:Ge,stop:Ye,print:function(e){if(console.log("[perf timer statistics]"),e)Ve(e);else for(const e of Je.keys())Ve(e)}});const Qe=pe.sealedOptions,Xe=e.extend({props:Qe.props});let et=void 0;function tt(e,t,n){const o=e[t];Array.isArray(o)&&(e[t]=new n(o[0],o[1]))}function nt(e){return e&&0!==e.length?e.map(e=>{const t={...e};return tt(t,"size",AMap.Size),tt(t,"offset",AMap.Pixel),tt(t,"imageOffset",AMap.Pixel),t}):e}var ot=y(J).extend({name:"AmapMarkerCluster",amapMeta:{prepare:()=>p("AMap.MarkerCluster"),async initComponent(e,t){const n=this;return this.$scopedSlots.cluster&&(t.renderClusterMarker=n._renderCluster),this.$scopedSlots.marker&&(t.renderMarker=n._renderMarker),new e.MarkerCluster(n.$map,n.data||[],t)},events:["click"]},props:{data:F({type:Array,required:!0,initialize:!1}),gridSize:F("setGridSize",Number),maxZoom:F("setMaxZoom",Number),averageCenter:F({type:Boolean,default:void 0,setter:"setAverageCenter"}),clusterByZoomChange:{type:Boolean,default:void 0},styles:F({type:Array,setter(e,t){e.setStyles(nt(t))},transform:nt}),markerOptions:F({type:Function,initialize:!1}),clusterOptions:F({type:Function,initialize:!1})},data:()=>({$mcc:null}),mounted(){const t=function(e,t,n){let o,r,a,i,s;function p(){var l=Date.now()-i;l<t&&l>=0?o=setTimeout(p,t-l):(o=null,n||(s=e.apply(a,r),a=r=null))}null==t&&(t=100);var l=function(...l){a=this,r=l,i=Date.now();var c=n&&!o;return o||(o=setTimeout(p,t)),c&&(s=e.apply(a,r),a=r=null),s};return l.clear=function(){o&&(clearTimeout(o),o=null)},l.flush=function(){o&&(s=e.apply(a,r),a=r=null,clearTimeout(o),o=null)},l}(this._onDataChange,100),n=this.$scopedSlots.marker,o=this.$scopedSlots.cluster,{$context:r}=this;r.ready.then(()=>{this._onDataChange()});const a=e.extend({props:{point:{type:Object}},render(){if(!n)return null;return Be(n(this.point),"0",null)}}),i=e.extend({props:{context:{type:Object}},render(){if(!o)return null;return Be(o(this.context),"0",null)}});this.$mcc={marker:new a,cluster:new i,dummy:new Xe},this.$watch("data",{handler:t})},beforeDestroy(){this.$mcc.marker.$destroy(),this.$mcc.cluster.$destroy(),this.$mcc.dummy.$destroy()},methods:{async _onDataChange(){const{data:e,$context:t}=this;await t.ready,t.destroyed||this.$target.setData(e)},_renderMarkerContent(e,t,n){Ge("MarkerCluster#_renderMarkerContent");const o=function(e,t){et||(et=document.createElement("div"));const n=e;return n._props=t,n._vnode=null,n.$mount(et),n._vnode.elm}(t,n);e.marker.setContent(o),Ye("MarkerCluster#_renderMarkerContent")},_setMarkerOptions(e,t,n){const o={};"function"==typeof t&&Object.assign(o,t(n));const r=Object.keys(o),{dummy:a}=this.$mcc;for(let t=0;t<r.length;++t){const n=r[t],i=o[n],s=Qe.props[n];void 0!==s&&W(a,e.marker,s,i)}},_renderMarker(e){Ge("MarkerCluster#_renderMarker");const t=e.data[0],n={point:t};this._renderMarkerContent(e,this.$mcc.marker,n),this._setMarkerOptions(e,this.markerOptions,t),Ye("MarkerCluster#_renderMarker")},_renderCluster(e){Ge("MarkerCluster#_renderCluster");const t={context:e};this._renderMarkerContent(e,this.$mcc.cluster,t),this._setMarkerOptions(e,this.clusterOptions,e),Ye("MarkerCluster#_renderCluster")}},render:()=>null});const rt=pe.sealedOptions,at=Me.sealedOptions,it=$e.sealedOptions,st=Se.sealedOptions,pt=ve.sealedOptions;var lt=y(J).extend({amapMeta:{prepare:()=>p("AMap.MouseTool"),async initComponent(e){return new e.MouseTool(this.$map)},add(){},remove(){}},props:{mode:F({type:String,default:"none"}),clearWhenClose:{type:Boolean,default:!0},options:{type:Object}},data:()=>({drawingMode:void 0}),computed:{$mousetool(){return this.$target}},methods:{close(e){this.$mousetool.close(e)},draw(){const{$mousetool:e,mode:t,drawingMode:n}=this;if(t!==n){switch(t){case"none":this.close(this.clearWhenClose);break;case"marker":e.marker(_(this,rt.props,this.options||{}));break;case"polyline":e.polyline(_(this,at.props,this.options||{}));break;case"polygon":e.polygon(_(this,it.props,this.options||{}));break;case"rectangle":e.rectangle(_(this,st.props,this.options||{}));break;case"circle":e.circle(_(this,pt.props,this.options||{}));break;case"rule":e.rule(_(this,it.props,this.options||{}));break;case"measureArea":e.measureArea(_(this,it.props,this.options||{}));break;case"rectZoomIn":e.rectZoomIn(_(this,it.props,this.options||{}));break;case"rectZoomOut":e.rectZoomOut(_(this,it.props,this.options||{}))}this.drawingMode=t}},_onDraw(e){if(this.mode!==this.drawingMode)return this.close(!0),void this.draw();const t=e.obj,n=this.drawingMode;let o=t;switch(n){case"marker":o=j(t.getPosition());break;case"polyline":case"polygon":o=P(t.getPath());break;case"rectangle":o=L(t.getBounds());break;case"circle":o={center:j(t.getCenter()),radius:t.getRadius()};break;case"rule":o={path:P(t.getPath()),length:t.getLength()};break;case"measureArea":o={path:P(t.getPath()),area:t.getArea()}}this.$emit("draw",n,o),this.$emit("update:mode","none")}},async mounted(){const{$context:e}=this;if(await e.ready,e.destroyed)return;const{$mousetool:t}=this;t.on("draw",this._onDraw),this.$watch("mode",e=>{"none"!==e&&"none"!==this.drawingMode&&this.close(!0),this.draw()},{immediate:!0})}}),ct=y(J,G(!0),Y,Q,X).extend({amapMeta:{events:["complete"]},async mounted(){await this.$context.ready,this.$context.destroyed||this.visible||this.$target.hide()}}),dt=y(ct).extend({name:"AmapImageLayer",amapMeta:{initComponent:async(e,t)=>new e.ImageLayer(t)},props:{bounds:F({type:Array,transform:T,deep:!0,setter(e,t){e.setBounds(T(t))}}),url:F("setImageUrl",String)}}),ut=y(ct).extend({name:"AmapCanvasLayer",amapMeta:{slot:!0,async initComponent(e,t){const n=Be(this,"$slots.default.0.elm");if(!n||"CANVAS"!==n.tagName)throw this.$amap.logger.warn("slot内容必须是canvas"),new Error;return t.canvas=n,new e.CanvasLayer(t)}},props:{bounds:F({type:Array,transform:T})}}),mt=y(ct).extend({name:"AmapCustomLayer",amapMeta:{slot:!0,async initComponent(e,t){const n=Be(this,"$slots.default.0.elm");if(!n||"CANVAS"!==n.tagName)throw this.$amap.logger.warn("slot内容必须是canvas"),new Error;return new e.CustomLayer(n,t)}},props:{render:F({type:Function,required:!0})}}),yt=y(J,G(!0),Y,Q,X).extend({amapMeta:{prepare:()=>p("AMap.DistrictLayer"),events:["complete"]},props:{styles:F({type:Object,setter:"setStyles"})}});const ft=e.extend({props:{depth:{type:Number}}});var ht=y(yt).extend({name:"AmapDistrictLayerWorld",amapMeta:{initComponent:async(e,t)=>new e.DistrictLayer.World(t)}}),gt=y(yt,ft).extend({name:"AmapDistrictLayerCountry",amapMeta:{initComponent:async(e,t)=>("soc"in t&&(t.SOC=t.soc,delete t.soc),new e.DistrictLayer.Country(t))},props:{soc:F("setSOC",String)}}),vt=y(yt,ft).extend({name:"AmapDistrictLayerProvince",amapMeta:{initComponent:async(e,t)=>new e.DistrictLayer.Province(t)},props:{adcode:F({type:[Array,String,Number],deep:!0,equals:A,setter:"setDistricts"})}}),bt={install(e){e.component("amap",H),e.component("amap-marker",pe),e.component("amap-labels-layer",le),e.component("amap-label-marker",ce),e.component("amap-text",de),e.component("amap-circle",ve),e.component("amap-circle-marker",be),e.component("amap-polygon",$e),e.component("amap-polyline",Me),e.component("amap-bezier-curve",ke),e.component("amap-rectangle",Se),e.component("amap-ellipse",Oe),e.component("amap-info-window",_e),e.component("amap-tile-layer",Le),e.component("amap-satellite-layer",Pe),e.component("amap-road-net-layer",ze),e.component("amap-traffic-layer",De),e.component("amap-flexible-layer",Te),e.component("amap-map-type",We),e.component("amap-control-bar",Ze),e.component("amap-hawk-eye",Fe),e.component("amap-scale",Ue),e.component("amap-tool-bar",He),e.component("amap-marker-cluster",ot),e.component("amap-mouse-tool",lt),e.component("amap-image-layer",dt),e.component("amap-canvas-layer",ut),e.component("amap-custom-layer",mt),e.component("amap-district-layer-world",ht),e.component("amap-district-layer-country",gt),e.component("amap-district-layer-province",vt)},config:t,loadAmap:s,loadPlugins:p,withAmap:l,Amap:H,Marker:pe,LabelsLayer:le,LabelMarker:ce,Text:de,Circle:ve,CircleMarker:be,Polygon:$e,Polyline:Me,BezierCurve:ke,Rectangle:Se,Ellipse:Oe,InfoWindow:_e,TileLayer:Le,SatelliteLayer:Pe,FlexibleLayer:Te,RoadNetLayer:ze,TrafficLayer:De,MapType:We,ControlBar:Ze,HawkEye:Fe,Scale:Ue,ToolBar:He,MarkerCluster:ot,MouseTool:lt,ImageLayer:dt,CanvasLayer:ut,CustomLayer:mt,DistrictLayerWorld:ht,DistrictLayerCountry:gt,DistrictLayerProvince:vt};export default bt;export{H as Amap,ke as BezierCurve,ut as CanvasLayer,ve as Circle,be as CircleMarker,Ze as ControlBar,mt as CustomLayer,gt as DistrictLayerCountry,vt as DistrictLayerProvince,ht as DistrictLayerWorld,Oe as Ellipse,Te as FlexibleLayer,Fe as HawkEye,dt as ImageLayer,_e as InfoWindow,ce as LabelMarker,le as LabelsLayer,We as MapType,pe as Marker,ot as MarkerCluster,lt as MouseTool,$e as Polygon,Me as Polyline,Se as Rectangle,ze as RoadNetLayer,Pe as SatelliteLayer,Ue as Scale,de as Text,Le as TileLayer,He as ToolBar,De as TrafficLayer,t as config,s as loadAmap,p as loadPlugins,l as withAmap};
